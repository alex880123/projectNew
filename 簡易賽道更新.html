
<html>
<head>
<style>
#info {
  position: absolute;
  top: 0px;
  right: 25%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

#infon {
  position: absolute;
  top: 0px;
  left: 25%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}


#countDown {
  position: absolute;
  top: 50px;
  left: 0%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00;
}

body {
  overflow: hidden;
}
</style>
</head>

 


<body> 

<span id="countDown" style="color:red" >倒數：<span id="Check_i2">3秒</span></span>

<script type="text/javascript">
var SetMinute2 = 3;

  function Check_Time2() {
      SetMinute2 -= 1;
      var Check_i2 = document.getElementById("Check_i2");

      Cal_Second2 = SetMinute2 % 60;

      Check_i2.innerHTML = Cal_Second2 + "秒";
	  if(Cal_Second2==0){
		alert("Start!");
		clearInterval(mm2)
		
	  }
	  
    }
  var mm2 = window.setInterval("Check_Time2()", 1000);
 </script>

<span id="info" style="color:red">時間計數：<span id="Check_i">0秒</span></span>
<script type="text/javascript">
  var SetMinute = 0;

  function Check_Time() {
      SetMinute += 1;
      var Check_i = document.getElementById("Check_i");

      var Cal_Second = SetMinute % 60;

      Check_i.innerHTML = Cal_Second + "秒";
	  
	  	   const heartShape = new THREE.Shape();

heartShape.moveTo(0,0 );
heartShape.lineTo(-10,10);
heartShape.lineTo(0,20);
heartShape.lineTo(-20,20);
heartShape.lineTo(-30,10);
heartShape.lineTo(-20,0);

//heartShape.lineTo(-25,25);

/*heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );
heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );*/

var hgeometry = new THREE.ShapeGeometry( heartShape );
var hmaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00,side: THREE.DoubleSide } );
var hmesh = new THREE.Mesh( hgeometry, hmaterial ) ;
hmesh.position.set(70,0.1,-160);
hmesh.rotation.x = Math.PI/2;
hmesh.rotation.z = Math.PI/2;

var hgeometry1 = new THREE.ShapeGeometry( heartShape );
var hmaterial1 = new THREE.MeshBasicMaterial( { color: 0x00ff00,side: THREE.DoubleSide } );
var hmesh1 = new THREE.Mesh( hgeometry1, hmaterial1 ) ;
hmesh1.position.set(70,0.1,-190);
hmesh1.rotation.x = Math.PI/2;
hmesh1.rotation.z = 1.4;

var hgeometry2 = new THREE.ShapeGeometry( heartShape );
var hmaterial2 = new THREE.MeshBasicMaterial( { color: 0x00ff00,side: THREE.DoubleSide } );
var hmesh2 = new THREE.Mesh( hgeometry2, hmaterial2 ) ;
hmesh2.position.set(65,0.1,-220);
hmesh2.rotation.x = Math.PI/2;
hmesh2.rotation.z = 1.3;

var hmeshn = hmesh.clone();
hmeshn.position.set(120, 0.1, -160);
hmeshn.rotation.z = Math.PI/2;

var hmeshn1 = hmesh1.clone();
hmeshn1.position.set(120, 0.1, -190);
hmeshn1.rotation.z = 1.4;

var hmeshn2 = hmesh2.clone();
hmeshn2.position.set(115, 0.1, -220);
hmeshn2.rotation.z = 1.3;

var hmesh21 = hmesh2.clone();
hmesh21.position.set(70, 0.1, -30);
hmesh21.rotation.z = Math.PI/2;

var hmesh22 = hmesh1.clone();
hmesh22.position.set(70, 0.1, 0);
hmesh22.rotation.z = Math.PI/2;

var hmesh23 = hmesh.clone();
hmesh23.position.set(70, 0.1, 30);
hmesh23.rotation.z = Math.PI/2;

var hmeshn3 = hmesh2.clone();
hmeshn3.position.set(120, 0.1, -30);
hmeshn3.rotation.z = Math.PI/2;

var hmeshn4 = hmesh1.clone();
hmeshn4.position.set(120, 0.1, 0);
hmeshn4.rotation.z = Math.PI/2;

var hmeshn5 = hmesh.clone();
hmeshn5.position.set(120, 0.1, 30);
hmeshn5.rotation.z = Math.PI/2;

var hmesh3 = hmesh.clone();
hmesh3.position.set(-530, 0.1, -440);
hmesh3.rotation.z = 0.1;

var hmesh4 = hmesh1.clone();
hmesh4.position.set(-560, 0.1, -440);
hmesh4.rotation.z = -0.1;

var hmesh5 = hmesh2.clone();
hmesh5.position.set(-590, 0.1, -435);
hmesh5.rotation.z = -0.3;

var hmeshn6 = hmesh.clone();
hmeshn6.position.set(-530, 0.1, -490);
hmeshn6.rotation.z = 0.1;

var hmeshn7 = hmesh1.clone();
hmeshn7.position.set(-560, 0.1, -490);
hmeshn7.rotation.z = -0.1;

var hmeshn8 = hmesh2.clone();
hmeshn8.position.set(-590, 0.1, -485);
hmeshn8.rotation.z = -0.3;

var hmesh24 = hmesh.clone();
hmesh24.position.set(-300, 0.1, -439);
hmesh24.rotation.z = 0.1;

var hmesh25 = hmesh1.clone();
hmesh25.position.set(-330, 0.1, -440);
hmesh25.rotation.z = 0.1;

var hmesh26 = hmesh2.clone();
hmesh26.position.set(-360, 0.1, -441);
hmesh26.rotation.z = 0.1;

var hmeshn9 = hmesh.clone();
hmeshn9.position.set(-300, 0.1, -489);
hmeshn9.rotation.z = 0.1;

var hmeshn10 = hmesh1.clone();
hmeshn10.position.set(-330, 0.1, -490);
hmeshn10.rotation.z = 0.1;

var hmeshn11 = hmesh2.clone();
hmeshn11.position.set(-360, 0.1, -491);
hmeshn11.rotation.z = 0.1;




var hmesh27 = hmesh.clone();
hmesh27.position.set(-805, 0.1, -130);
hmesh27.rotation.z = -1.57;

var hmesh28 = hmesh1.clone();
hmesh28.position.set(-805, 0.1, -100);
hmesh28.rotation.z = -1.57;

var hmesh29 = hmesh2.clone();
hmesh29.position.set(-805, 0.1, -70);
hmesh29.rotation.z = -1.57;

var hmeshn12 = hmesh.clone();
hmeshn12.position.set(-855, 0.1, -130);
hmeshn12.rotation.z = -1.57;

var hmeshn13 = hmesh1.clone();
hmeshn13.position.set(-855, 0.1, -100);
hmeshn13.rotation.z = -1.57;

var hmeshn14 = hmesh2.clone();
hmeshn14.position.set(-855, 0.1, -70);
hmeshn14.rotation.z = -1.57;



var hmesh6 = hmesh.clone();
hmesh6.position.set(-805, 0.1, 150);
hmesh6.rotation.z = -1.57;

var hmesh7 = hmesh1.clone();
hmesh7.position.set(-805, 0.1, 180);
hmesh7.rotation.z = -1.8;

var hmesh8 = hmesh2.clone();
hmesh8.position.set(-800, 0.1, 210);
hmesh8.rotation.z = -2.0;

var hmeshn15 = hmesh.clone();
hmeshn15.position.set(-855, 0.1, 150);
hmeshn15.rotation.z = -1.57;

var hmeshn16 = hmesh1.clone();
hmeshn16.position.set(-855, 0.1,180);
hmeshn16.rotation.z = -1.8;

var hmeshn17 = hmesh2.clone();
hmeshn17.position.set(-850, 0.1, 210);
hmeshn17.rotation.z = -2.0;


var hmesh30 = hmesh2.clone();
hmesh30.position.set(-337.5, 0.1, 270);
hmesh30.rotation.z = Math.PI;

var hmesh31 = hmesh1.clone();
hmesh31.position.set(-367.5, 0.1, 270);
hmesh31.rotation.z = Math.PI;

var hmesh32 = hmesh.clone();
hmesh32.position.set(-397.5, 0.1, 270);
hmesh32.rotation.z = Math.PI;

var hmeshn18 = hmesh2.clone();
hmeshn18.position.set(-337.5, 0.1, 320);
hmeshn18.rotation.z = Math.PI;

var hmeshn19 = hmesh1.clone();
hmeshn19.position.set(-367.5, 0.1, 320);
hmeshn19.rotation.z = Math.PI;

var hmeshn20 = hmesh.clone();
hmeshn20.position.set(-397.5, 0.1, 320);
hmeshn20.rotation.z = Math.PI;

var hmesh9 = hmesh.clone();
hmesh9.position.set(-30, 0.1, 270);
hmesh9.rotation.z = Math.PI;

var hmesh10 = hmesh1.clone();
hmesh10.position.set(0, 0.1, 270);
hmesh10.rotation.z = 2.9;

var hmesh11 = hmesh2.clone();
hmesh11.position.set(30, 0.1, 265);
hmesh11.rotation.z = 2.7;

var hmeshn21 = hmesh.clone();
hmeshn21.position.set(-30, 0.1, 320);
hmeshn21.rotation.z = Math.PI;

var hmeshn22 = hmesh1.clone();
hmeshn22.position.set(0, 0.1, 320);
hmeshn22.rotation.z = 2.9;

var hmeshn23 = hmesh2.clone();
hmeshn23.position.set(30, 0.1, 315);
hmeshn23.rotation.z = 2.7;




scene.add( hmesh,hmesh1,hmesh2,hmesh3,hmesh4,hmesh5,hmesh6,hmesh7,hmesh8,hmesh9,hmesh10,hmesh11,hmesh21,hmesh22,hmesh23,hmesh24,hmesh25,hmesh26,hmesh27,hmesh28,hmesh29,hmesh30,hmesh31,hmesh32,hmeshn,hmeshn1,hmeshn2,hmeshn3,hmeshn4,hmeshn5,hmeshn6,hmeshn7,hmeshn8,hmeshn9,hmeshn10,hmeshn11,hmeshn12,hmeshn13,hmeshn14,hmeshn15,hmeshn16,hmeshn17,hmeshn18,hmeshn19,hmeshn20,hmeshn21,hmeshn22,hmeshn23);
		
		if(Cal_Second%4 == 1){
		hmesh.material.color.setHex(0xffff00);
		hmesh1.material.color.setHex(0x888888);
		hmesh2.material.color.setHex(0x888888);
		}
		
		if(Cal_Second%4 == 2){
		hmesh.material.color.set(0xffff00);
		hmesh1.material.color.set(0xffff00);
		hmesh2.material.color.set(0x888888);
		}
		
		if(Cal_Second%4 == 3){
		hmesh.material.color.set(0xffff00);
		hmesh1.material.color.set(0xffff00);
		hmesh2.material.color.set(0xffff00);
		}
		
		if(Cal_Second%4 == 0){
		hmesh.material.color.set(0x888888);
		hmesh1.material.color.set(0x888888);
		hmesh2.material.color.set(0x888888);
		}
	  
	 } 
  var mm = window.setInterval("Check_Time()", 1000);

</script>

<span id="infon" style="color:red">時間計數1：<span id="Check_i1">0秒</span></span>
<script type="text/javascript">
  var SetMinute1 = 0;

  function Check_Time1() {
      SetMinute1 += 1;
      var Check_i1 = document.getElementById("Check_i1");

      var Cal_Second1 = SetMinute1 % 60;

      Check_i1.innerHTML = Cal_Second1 + "秒";
	  
    }
  var mm1 = window.setInterval("Check_Time1()", 1000);


</script>

<script id='myVertexShader' type="x-shader/x-vertex">
    varying vec4 wPos;
    varying vec2 vUv;
    uniform vec2 scale;
    uniform vec2 offset;

    void main() {
        vUv = uv * scale + offset;
        wPos = modelMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id='myFragmentShader' type="x-shader/x-vertex">
    //
    // FROM: http://jsfiddle.net/jmchen/cby3d1ag/
    //
    vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
        return mod289(((x * 34.0) + 1.0) * x);
    }

    vec4 taylorInvSqrt(vec4 r) {
        return 1.79284291400159 - 0.85373472095314 * r;
    }

    float snoise(vec3 v) {
        const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        // First corner
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
        //   x1 = x0 - i1  + 1.0 * C.xxx;
        //   x2 = x0 - i2  + 2.0 * C.xxx;
        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y

        // Permutations
        i = mod289(i);
        vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        float n_ = 0.142857142857; // 1.0/7.0
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        //Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),
        dot(p2, x2), dot(p3, x3)));
    }

    uniform int terms;
    uniform int use2D;
    uniform float time;
    varying vec2 vUv;
    varying vec4 wPos;
    
    float surface3(vec3 coord) {
        float height = 0.0;
        height += abs(snoise(coord)) * 1.0;
        if (terms >= 2)    
            height += abs(snoise(coord * 2.0)) * 0.5;
        if (terms >= 3)
            height += abs(snoise(coord * 4.0)) * 0.25;
        if (terms >= 4)
            height += abs(snoise(coord * 8.0)) * 0.125;
		if (terms >= 5)
            height += abs(snoise(coord * 16.0)) * 0.0625;
        // can add more terms ...
        if (terms >= 6)   
             height += abs(snoise(coord * 32.0)) * 0.03125;
		if (terms >= 7)    
            height += abs(snoise(coord * 64.0)) * 0.015625;
        if (terms >= 8)
            height += abs(snoise(coord * 128.0)) * 0.0078125;
        if (terms >= 9)
            height += abs(snoise(coord * 256.0)) * 0.00390625;
        // can add more terms ...
        if (terms >= 10)   
             height += abs(snoise(coord * 512.0)) * 0.001953125;	 
        return height;
    }

    void main() {
        float scale = 1.0;
        vec3 coord = vec3(scale * vUv[0], scale * vUv[1], time);
        float height = surface3(coord);

        float r;
        r = height;
        gl_FragColor = vec4(0, r*0.5, r*0.6, 1.0);
    }
</script>



<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/misc/Gyroscope.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<audio id="collisionsound" style="display:none">
  <source src="music/glass.wav" type='audio/wav'>
</audio>

<audio id="collisionsound1" style="display:none">
  <source src="music/car.mp3" type='audio/mp3'>
</audio>

<script>
var camera, camera3rd, scene, renderer;
var gyro;
var useGyro = true;
var windowHalfX = window.innerWidth;
var windowHalfY = window.innerHeight;
var car, car1,carmesh;
var SetMinute = 0;
var walls = [],walls1 = [];
var dt = 0.1,
  dm = 0.1;
var eps = 1e-3;
var keyboard = new KeyboardState(),
  keyboard1 = new KeyboardState();
var collisionSound;
var collisionSound1;

var SpotLight, lightSphere;
var angle1 = 0,angle2 = 0,angle3 = 0;
var carFrontPos = new THREE.Vector3(),
  carFrontPos1 = new THREE.Vector3();
var leftTop = new THREE.Vector3(),
  leftTop1 = new THREE.Vector3();
var rightTop = new THREE.Vector3(),
  rightTop1 = new THREE.Vector3();
var rightButtom = new THREE.Vector3(),
  rightButtom1 = new THREE.Vector3();
var leftButtom = new THREE.Vector3(),
  leftButtom1 = new THREE.Vector3();
var raceLine;
var Omega, Omega1;
var cube;
var count = 0;
var mesh,floor;
var mm;
var wheelLight = new THREE.PointLight( 'red', 2,20);
var carModel = new THREE.Object3D();
var carnModel = new THREE.Object3D();
var modelName = "car";
var modelName1 = "carn";
var Cal_Second2;
var i = 0,
  j = 3,
  k = 0,
  m = 1,
  a = 0,
  b = 0;

(function() {
  Math.clamp = function(val, min, max) {
    return Math.min(Math.max(val, min), max);

  }
})();

class Car {
  constructor(pos) {
    this.collisionSound = document.getElementById('collisionsound');
	this.collisionSound1 = document.getElementById('collisionsound1');
    this.name = "Mini_4WD";
	this.light = wheelLight;
	this.light1 = wheelLight.clone();
	this.light2 = wheelLight.clone();
	this.light3 = wheelLight.clone();
	scene.add(this.light,this.light1,this.light2,this.light3);
    this.pos = new THREE.Vector3(60, 2, 150);
    this.vel = new THREE.Vector3();
    this.mesh = buildcar();
    this.normal = new THREE.Vector3(0, 0, 1)
    this.force = new THREE.Vector3();
    this.angle = 0;
    this.speed = 0;
	this.castShadow = true;
	this.receiveShadow = true;
    scene.add(this.mesh);
  }

  update(dt) {
	//this.collisionSound1.play();
    rightTop.copy(this.mesh.localToWorld(new THREE.Vector3(13, 0, -13))) //右前導輪

    leftTop.copy(this.mesh.localToWorld(new THREE.Vector3(-13, 0, -13))); //左前導輪
    leftButtom.copy(this.mesh.localToWorld(new THREE.Vector3(-13, 0, 13))) //左後導輪
    rightButtom.copy(this.mesh.localToWorld(new THREE.Vector3(13, 0, 13))) //右後導輪

    carFrontPos.copy(this.mesh.localToWorld(new THREE.Vector3(0, 0, -18))); //車頭
    /////////////////////////////////////////////////////

    keyboard.update();
    if (keyboard.down("W") || keyboard.pressed("W")){
      this.speed -= 0.1;
	  this.mesh.children[4].rotation.x -= 0.02;
	  this.mesh.children[5].rotation.x -= 0.02;
	  this.mesh.children[6].rotation.x -= 0.02;
	  this.mesh.children[7].rotation.x -= 0.02;
}

    if (keyboard.down("S") || keyboard.pressed("S")){
      this.speed += 0.1;
	  this.mesh.children[4].rotation.x += 0.02;
	  this.mesh.children[5].rotation.x += 0.02;
	  this.mesh.children[6].rotation.x += 0.02;
	  this.mesh.children[7].rotation.x += 0.02;
    }

    if (keyboard.down("A") || keyboard.pressed("A")){
      this.angle += 0.01;
	  angle2 += 0.01;
	  this.mesh.children[4].rotation.y = 0.05;
	  this.mesh.children[5].rotation.y = 0.05;
	  this.mesh.children[6].rotation.y = 0.05;
	  this.mesh.children[7].rotation.y = 0.05;
	  carModel.rotation.y = angle2;
}

    if (keyboard.down("D") || keyboard.pressed("D")){
      this.angle -= 0.01; 
	  angle2 -= 0.01
	  this.mesh.children[4].rotation.y = -0.05;
	  this.mesh.children[5].rotation.y = -0.05;
	  this.mesh.children[6].rotation.y = -0.05;
	  this.mesh.children[7].rotation.y = -0.05;
	  carModel.rotation.y = angle2;
}
    this.speed = Math.clamp(this.speed, -50.0, 50.0);
    this.vel = new THREE.Vector3(0, 0, this.speed);
    this.vel.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.angle);
    this.pos.add(this.vel.clone().multiplyScalar(dt));
	
    this.mesh.position.copy(this.pos);
	this.light.position.copy(rightTop);
	this.light1.position.copy(leftTop);
	this.light2.position.copy(rightButtom);
	this.light3.position.copy(leftButtom);
    this.mesh.rotation.y = this.angle;
  
	//console.log(this.mesh.children[0].position);
  }
}

class Car1 {
  constructor(pos) {
    this.collisionSound = document.getElementById('collisionsound');
    this.name = "Mini_4WD";
    this.pos = new THREE.Vector3(110, 2, 150);
    this.vel = new THREE.Vector3();
    this.mesh = buildcar();
    this.normal = new THREE.Vector3(0, 0, 1)
    this.force = new THREE.Vector3();
    this.angle = 0;
    this.speed = 0;
	this.light = wheelLight;
	this.light1 = wheelLight.clone();
	this.light2 = wheelLight.clone();
	this.light3 = wheelLight.clone();
	scene.add(this.light,this.light1,this.light2,this.light3);
    scene.add(this.mesh);
  }

  update(dm) {

    rightTop1.copy(this.mesh.localToWorld(new THREE.Vector3(13, 0, -13))) //右前導輪

    leftTop1.copy(this.mesh.localToWorld(new THREE.Vector3(-13, 0, -13))); //左前導輪
    leftButtom1.copy(this.mesh.localToWorld(new THREE.Vector3(-13, 0, 13))) //左後導輪
    rightButtom1.copy(this.mesh.localToWorld(new THREE.Vector3(13, 0, 13))) //右後導輪

    carFrontPos1.copy(this.mesh.localToWorld(new THREE.Vector3(0, 0, -18))); //車頭
    /////////////////////////////////////////////////////

    keyboard1.update();
    if (keyboard1.down("I") || keyboard1.pressed("I")){
      this.speed -= 0.1;
	  this.mesh.children[4].rotation.x -= 0.02;
	  this.mesh.children[5].rotation.x -= 0.02;
	  this.mesh.children[6].rotation.x -= 0.02;
	  this.mesh.children[7].rotation.x -= 0.02;
}

    if (keyboard1.down("K") || keyboard1.pressed("K")){
      this.speed += 0.1;
	  this.mesh.children[4].rotation.x += 0.02;
	  this.mesh.children[5].rotation.x += 0.02;
	  this.mesh.children[6].rotation.x += 0.02;
	  this.mesh.children[7].rotation.x += 0.02;
}

    if (keyboard1.down("J") || keyboard1.pressed("J")){
      this.angle += 0.01;
	  angle3 += 0.01;
	  this.mesh.children[4].rotation.y = 0.05;
	  this.mesh.children[5].rotation.y = 0.05;
	  this.mesh.children[6].rotation.y = 0.05;
	  this.mesh.children[7].rotation.y = 0.05;
	  carnModel.rotation.y = angle3;
	  }

    if (keyboard1.down("L") || keyboard1.pressed("L")){
      this.angle -= 0.01; 
	  angle3 -= 0.01
	  this.mesh.children[4].rotation.y = -0.05;
	  this.mesh.children[5].rotation.y = -0.05;
	  this.mesh.children[6].rotation.y = -0.05;
	  this.mesh.children[7].rotation.y = -0.05;
	  carnModel.rotation.y = angle3;
}
    this.speed = Math.clamp(this.speed, -50.0, 50.0);
    this.vel = new THREE.Vector3(0, 0, this.speed);
    this.vel.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.angle);
    this.pos.add(this.vel.clone().multiplyScalar(dt));

    this.mesh.position.copy(this.pos);
	this.light.position.copy(rightTop1);
	this.light1.position.copy(leftTop1);
	this.light2.position.copy(rightButtom1);
	this.light3.position.copy(leftButtom1);
    this.mesh.rotation.y = this.angle;

  }
}

class Curve1 {
  constructor(pos, angle) {
    this.pos = pos.clone();
    this.mesh = buildCurve1();
    this.mesh.rotation.y = angle;
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
    console.log(this.mesh)
  }
}

class Curve2 {
  constructor(pos, angle) {
    this.pos = pos.clone();
    this.mesh = buildCurve2();
    this.mesh.rotation.y = angle;
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);

  }
}

class Curve3 {
  constructor(pos, angle) {
    this.pos = pos.clone();
    this.mesh = buildCurve3();
    this.mesh.rotation.y = angle;
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);

  }
}

class Straight {
  constructor(pos) {
    this.pos = pos.clone();
    this.mesh = buildStraight();
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
  }
}


init();
animate();

function makeShaderMaterial() {
 	var material = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        uniforms: {
            terms: {
                type: 'i',
                value: 10
            },
            time: {
                type: 'f',
                value: 1.0
            },
            scale: {
                type: 'v2',
                value: new THREE.Vector2(1, 1)
            },
            offset: {
                type: 'v2',
                value: new THREE.Vector2(0, 0)
            }
        },
        vertexShader: document.getElementById('myVertexShader').textContent,
        fragmentShader: document.getElementById('myFragmentShader').textContent,

    });	
	return material;
}

function init() {

clock = new THREE.Clock();
  
  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer();
  renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor ('black');
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0, 50, 0);

  camera3rd = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
  camera3rd.position.set(0, 50, 0);

  camera3rd1 = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
  camera3rd1.position.set(0, 50, 0);

  renderer.autoClear = false;

  let controls = new THREE.OrbitControls(camera, renderer.domElement);

  function onWindowResize() {

    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    camera3rd.aspect = window.innerWidth / window.innerHeight;
    camera3rd.updateProjectionMatrix();

    camera3rd1.aspect = window.innerWidth / window.innerHeight;
    camera3rd1.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }
readModel('car',40);
readModel1('carn',40);
  ////////////////////////////////////////////////////////////////
  

var starting_line = new THREE.TextureLoader()
  starting_line.crossOrigin = '';

  race = starting_line.load('https://i.imgur.com/vaCaTCH.jpg?1');

  var geometry = new THREE.PlaneGeometry(50, 20, 1);
  var material = new THREE.MeshBasicMaterial({
    map:race,
    side: THREE.DoubleSide
  });
  raceLine = new THREE.Mesh(geometry, material);
  raceLine.position.set(60, 1, 112);
  raceLine.rotation.x = -Math.PI / 2;

  var raceLine1 = raceLine.clone();
  raceLine1.position.set(110, 1, 112);
  scene.add(raceLine, raceLine1);


  scene.add(raceLine, raceLine1);

var loader1 = new THREE.TextureLoader()
  loader1.crossOrigin = '';

  background = loader1.load('https://i.imgur.com/xC718QD.jpg');

 materialFloor = makeShaderMaterial();
   floor = new THREE.Mesh (new THREE.PlaneGeometry (1200,1000,100,100), materialFloor)
   floor.position.set (-400,0,-100);
   floor.rotation.x = Math.PI/2;
  scene.add( floor );


  car = new Car(new THREE.Vector3(0, 0, 50));
  car1 = new Car1(new THREE.Vector3(0, 0, 110))
  car.castShadow = true; //default is false
  car.receiveShadow = true; //default
  
  
  camera.position.set(50, 600, 50);
  gyro = new THREE.Gyroscope();
  scene.add(gyro)
  gyro.add(camera);
  car1.mesh.add(gyro);
  
const geometry123 = new THREE.BoxGeometry( 10, 10, 10 );
const material123 = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
const cube = new THREE.Mesh( geometry123, material123 );
cube.position.set(-735, 0, 200)
scene.add( cube );

  SpotLight = new THREE.SpotLight('white');
  //SpotLight.target = mesh1;
  scene.add(SpotLight);
	
  lightSphere = new THREE.Mesh(new THREE.SphereGeometry(5),
  new THREE.MeshBasicMaterial({
      color: 'white',
      wireframe: true
  }));
  scene.add(lightSphere);


  buildWall();


}

function updateSize() {
  if (windowHalfX != window.innerWidth || windowHalfY != window.innerHeight) {
    windowHalfX = window.innerWidth;
    windowHalfY = window.innerHeight;
    renderer.setSize(windowHalfX, windowHalfY);
  }
}


function buildcar() {

	let loader = new THREE.TextureLoader();
	loader.crossOrigin = '';
	texture = loader.load('https://i.imgur.com/lucRkZ7.jpg');
	
	let loader1 = new THREE.TextureLoader();
	loader1.crossOrigin = '';
	texture1 = loader1.load('https://i.imgur.com/gqnsT0P.png');
	
	let carmesh = new THREE.Mesh(new THREE.BoxGeometry(10, 2.5, 30), new THREE.MeshPhongMaterial({
    color: 'yellow',
	transparent: true,
	opacity: 0.9
  }));
  let mesh = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 2, 20), new THREE.MeshLambertMaterial({
    map:texture1
  }));
  wheel1 = mesh.clone();
  wheel2 = mesh.clone();
  wheel3 = mesh.clone();
  wheel4 = mesh.clone();
  carmesh.add(wheel1, wheel2, wheel3, wheel4);

  wheel1.position.set(9, 1, 18);
  wheel2.position.set(-9, 1, 18);
  wheel3.position.set(9, 1, -18);
  wheel4.position.set(-9, 1, -18);
  
  let mesh1 = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 4, 20), new THREE.MeshPhongMaterial({
    map:texture1
  }));
  mesh1.rotation.z = Math.PI/2;
  wheel5 = mesh1.clone();
  wheel6 = mesh1.clone();
  wheel7 = mesh1.clone();
  wheel8 = mesh1.clone();
  
  carmesh.add(wheel5, wheel6, wheel7, wheel8);
  
  wheel5.position.set(8, -10, 13);
  wheel6.position.set(-8, -10, 13);
  wheel7.position.set(8, -10, -13);
  
  wheel8.position.set(-8, -10, -13);
  
  let loader3 = new THREE.TextureLoader();
	loader3.crossOrigin = '';
	texture3 = loader3.load('https://i.imgur.com/xC718QD.jpg');

  return carmesh;
}

function buildCurve1() {

  var geometry = new THREE.CylinderGeometry(135, 135, 30, 30, 1, true, 1.57, 1.57);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var curve = new THREE.Mesh(geometry, material);
  return curve;
}

function buildCurve2() {

  var geometry = new THREE.CylinderGeometry(85, 85, 30, 30, 1, true, 1.57, 1.57);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var curve = new THREE.Mesh(geometry, material);
  return curve;
}

function buildCurve3() {

  var geometry = new THREE.CylinderGeometry(35, 35, 30, 30, 1, true, 1.57, 1.57);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var curve = new THREE.Mesh(geometry, material);
  return curve;
}

function buildStraight() {
  var geometry = new THREE.PlaneGeometry(400, 30, 80);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var straight = new THREE.Mesh(geometry, material);
  return straight;
}

function buildStraight1() {
  var geometry = new THREE.PlaneGeometry(735, 30, 80);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var straight = new THREE.Mesh(geometry, material);
  return straight;
}

function buildStraight2() {
  var geometry = new THREE.PlaneGeometry(350, 30, 80);
  var material = new THREE.MeshPhongMaterial({
    map: background,
    side: THREE.DoubleSide
  });
  var straight = new THREE.Mesh(geometry, material);
  return straight;
}

function buildWall() {

  var rightStraight_2 = buildStraight();

  rightStraight_2.position.set(35, 10, 0);
  rightStraight_2.point = new THREE.Vector3(35 + eps, 0, 0);
  rightStraight_2.normal = new THREE.Vector3(1, 0, 0);
  rightStraight_2.rotation.y = Math.PI / 2;

  var rightStraight_1 = buildStraight();

  rightStraight_1.position.set(85, 10, 0);
  rightStraight_1.point = new THREE.Vector3(85 + eps, 0, 0);
  rightStraight_1.normal = new THREE.Vector3(-1, 0, 0);
  rightStraight_1.rotation.y = Math.PI / 2;

  var groupStraight1 = new THREE.Group();
  groupStraight1.add(rightStraight_1);
  groupStraight1.add(rightStraight_2);
  groupStraight1.startLine = new THREE.Vector3(60, 0, 200);
  groupStraight1.endLine = new THREE.Vector3(60, 0, -200);
  groupStraight1.hat = new THREE.Vector3(0, 0, -1)
  groupStraight1.name = 'Straight';
  scene.add(groupStraight1);
  walls.push(groupStraight1);


  var curve1 = buildCurve2();

  curve1.position.set(0, 10, -200);
  curve1.point = new THREE.Vector3(0, 0, -200);
  curve1.normal = new THREE.Vector3(0, 0, 1);

  var curve2 = buildCurve3();

  curve2.position.set(0, 10, -200);
  curve2.point = new THREE.Vector3(0, 0, -200);
  curve2.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve1 = new THREE.Group();
  groupCurve1.add(curve1);
  groupCurve1.add(curve2);
  groupCurve1.radius = new THREE.Vector3(0, 0, -200);
  groupCurve1.startCurve = new THREE.Vector3(60, 0, -200);
  groupCurve1.endCurve = new THREE.Vector3(0, 0, -260);
  groupCurve1.angle = 90;
  groupCurve1.name = 'Curve';
  scene.add(groupCurve1);
  walls.push(groupCurve1);
  
  var curve3 = buildCurve2();

  curve3.position.set(0, 10, -370);
  curve3.point = new THREE.Vector3(0, 0, -200);
  curve3.normal = new THREE.Vector3(0, 0, 1);
  curve3.rotation.y = Math.PI/10*10;

  var curve4 = buildCurve1();

  curve4.position.set(0, 10, -370);
  curve4.point = new THREE.Vector3(0, 0, -200);
  curve4.normal = new THREE.Vector3(0, 0, 1);
  curve4.rotation.y = Math.PI/10*10;

  var groupCurve2 = new THREE.Group();
  groupCurve2.add(curve3);
  groupCurve2.add(curve4);
  groupCurve2.radius = new THREE.Vector3(0, 0, -370);
  groupCurve2.startCurve = new THREE.Vector3(0, 0, -260);
  groupCurve2.endCurve = new THREE.Vector3(-110, 0, -370);
  groupCurve2.angle = 90;
  groupCurve2.name = 'Curve';
  scene.add(groupCurve2);
  walls.push(groupCurve2);
  
  var curve5 = buildCurve3();

  curve5.position.set(-170, 10, -370);
  curve5.point = new THREE.Vector3(-170, 0, -370);
  curve5.normal = new THREE.Vector3(0, 0, 1);

  var curve6 = buildCurve2();

  curve6.position.set(-170, 10, -370);
  curve6.point = new THREE.Vector3(-170, 0, -370);
  curve6.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve3 = new THREE.Group();
  groupCurve3.add(curve5);
  groupCurve3.add(curve6);
  groupCurve3.radius = new THREE.Vector3(-170, 0, -370);
  groupCurve3.startCurve = new THREE.Vector3(-110, 0, -370);
  groupCurve3.endCurve = new THREE.Vector3(-170, 0, -430);
  groupCurve3.angle = 90;
  groupCurve3.name = 'Curve';
  scene.add(groupCurve3);
  walls.push(groupCurve3);
  
  
  
  var rightStraight_4 = buildStraight();

  rightStraight_4.position.set(-370, 10, -405);
  rightStraight_4.point = new THREE.Vector3(-370, 0, -405+eps);
  rightStraight_4.normal = new THREE.Vector3(0, 0, -1);

  var rightStraight_3 = buildStraight();

  rightStraight_3.position.set(-370, 10, -455);
  rightStraight_3.point = new THREE.Vector3(-370, 0, -455+eps);
  rightStraight_3.normal = new THREE.Vector3(0, 0, 1);

  var groupStraight2 = new THREE.Group();
  groupStraight2.add(rightStraight_3);
  groupStraight2.add(rightStraight_4);
  groupStraight2.startLine = new THREE.Vector3(-170, 0, -430);
  groupStraight2.endLine = new THREE.Vector3(-570, 0, -430);
  groupStraight2.hat = new THREE.Vector3(-1, 0, 0)
  groupStraight2.name = 'Straight';
  scene.add(groupStraight2);
  walls.push(groupStraight2);
  
  var curve7 = buildCurve3();

  curve7.position.set(-570, 10, -370);
  curve7.point = new THREE.Vector3(-570, 0, -370);
  curve7.rotation.y = Math.PI/2;
  curve7.normal = new THREE.Vector3(0, 0, -1);

  var curve8 = buildCurve2();

  curve8.position.set(-570, 10, -370);
  curve8.point = new THREE.Vector3(-570, 0, -370);
  curve8.rotation.y = Math.PI/2;
  curve8.normal = new THREE.Vector3(0, 0, -1);

  var groupCurve4 = new THREE.Group();
  groupCurve4.add(curve7);
  groupCurve4.add(curve8);
  groupCurve4.radius = new THREE.Vector3(-570, 0, -370);
  groupCurve4.startCurve = new THREE.Vector3(-570, 0, -430);
  groupCurve4.endCurve = new THREE.Vector3(-630, 0, -370);
  groupCurve4.angle = 90;
  groupCurve4.name = 'Curve';
  scene.add(groupCurve4);
  walls.push(groupCurve4);
  
  var curve9 = buildCurve2();

  curve9.position.set(-740, 10, -370);
  curve9.rotation.y = -Math.PI/2;
  curve9.normal = new THREE.Vector3(0, 0, -1);

  var curve10 = buildCurve1();

  curve10.position.set(-740, 10, -370);
  curve10.rotation.y = -Math.PI/2;
  curve10.normal = new THREE.Vector3(0, 0, -1);

  var groupCurve5 = new THREE.Group();
  groupCurve5.add(curve9);
  groupCurve5.add(curve10);
  groupCurve5.radius = new THREE.Vector3(-740, 0, -370);
  groupCurve5.startCurve = new THREE.Vector3(-630, 0, -370);
  groupCurve5.endCurve = new THREE.Vector3(-690, 0, -310);
  groupCurve5.angle = 90;
  groupCurve5.name = 'Curve';
  scene.add(groupCurve5);
  walls.push(groupCurve5);
  
  var curve11 = buildCurve2();

  curve11.position.set(-735, 10, -200);
  curve11.rotation.y = Math.PI/2;
  curve11.normal = new THREE.Vector3(0, 0, 1);

  var curve12 = buildCurve3();

  curve12.position.set(-735, 10, -200);
  curve12.rotation.y = Math.PI/2;
  curve12.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve6 = new THREE.Group();
  groupCurve6.add(curve11);
  groupCurve6.add(curve12);
  groupCurve6.radius = new THREE.Vector3(-735, 0, -200);
  groupCurve6.startCurve = new THREE.Vector3(-735, 0, -260);
  groupCurve6.endCurve = new THREE.Vector3(-795, 0, -200);
  groupCurve6.angle = 90;
  groupCurve6.name = 'Curve';
  scene.add(groupCurve6);
  walls.push(groupCurve6);
  
  var rightStraight_8 = buildStraight();

  rightStraight_8.position.set(-770, 10, 0);
  rightStraight_8.point = new THREE.Vector3(-770+eps, 0, 0);
  rightStraight_8.rotation.y = Math.PI/2;
  rightStraight_8.normal = new THREE.Vector3(-1, 0, 0);

  var rightStraight_7 = buildStraight();

  rightStraight_7.position.set(-820, 10, 0);
  rightStraight_7.point = new THREE.Vector3(-820+eps, 0, 0);
  rightStraight_7.rotation.y = Math.PI/2;
  rightStraight_7.normal = new THREE.Vector3(1, 0, 0);

  var groupStraight3 = new THREE.Group();
  groupStraight3.add(rightStraight_7);
  groupStraight3.add(rightStraight_8);
  groupStraight3.startLine = new THREE.Vector3(-795, 0, -200);
  groupStraight3.endLine = new THREE.Vector3(-795, 0, 200);
  groupStraight3.hat = new THREE.Vector3(0, 0, 1)
  groupStraight3.name = 'Straight';
  scene.add(groupStraight3);
  walls.push(groupStraight3);
  
  var curve13 = buildCurve3();

  curve13.position.set(-735, 10, 200);
  curve13.rotation.y = Math.PI/10*10;
  curve13.normal = new THREE.Vector3(0, 0, 1);

  var curve14 = buildCurve2();

  curve14.position.set(-735, 10, 200);
  curve14.rotation.y = Math.PI/10 * 10 ;
  curve14.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve7 = new THREE.Group();
  groupCurve7.add(curve13);
  groupCurve7.add(curve14);
  groupCurve7.radius = new THREE.Vector3(-735, 0, 200);
  groupCurve7.startCurve = new THREE.Vector3(-795, 0, 200);
  groupCurve7.endCurve = new THREE.Vector3(-735, 0, 260);
  groupCurve7.angle = 90;
  groupCurve7.name = 'Curve';
  scene.add(groupCurve7);
  walls.push(groupCurve7);
  
  var rightStraight_10 = buildStraight1();

  rightStraight_10.position.set(-367.5, 10, 235);
  rightStraight_10.point = new THREE.Vector3(-367.5, 0, 235+eps);
  rightStraight_10.normal = new THREE.Vector3(0, 0, 1);

  var rightStraight_9 = buildStraight1();

  rightStraight_9.position.set(-367.5, 10, 285);
  rightStraight_9.point = new THREE.Vector3(-367.5, 0, 285+eps);
  rightStraight_9.normal = new THREE.Vector3(0, 0, -1);

  var groupStraight4 = new THREE.Group();
  groupStraight4.add(rightStraight_9);
  groupStraight4.add(rightStraight_10);
  groupStraight4.startLine = new THREE.Vector3(-735, 0, 260);
  groupStraight4.endLine = new THREE.Vector3(0, 0, 260);
  groupStraight4.hat = new THREE.Vector3(1, 0, 0)
  groupStraight4.name = 'Straight';
  scene.add(groupStraight4);
  walls.push(groupStraight4);
/////////////////////////////////////////////////////////////////  
  var curve15 = buildCurve3();

  curve15.position.set(0, 10, 200);
  curve15.rotation.y = -Math.PI/2;
  curve15.normal = new THREE.Vector3(0, 0, 1);

  var curve16 = buildCurve2();

  curve16.position.set(0, 10, 200);
  curve16.rotation.y = -Math.PI/2 ;
  curve16.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve8 = new THREE.Group();
  groupCurve8.add(curve15);
  groupCurve8.add(curve16);
  groupCurve8.radius = new THREE.Vector3(0, 0, 200);
  groupCurve8.startCurve = new THREE.Vector3(0, 0, 260);
  groupCurve8.endCurve = new THREE.Vector3(60, 0, 200);
  groupCurve8.angle = 90;
  groupCurve8.name = 'Curve';
  scene.add(groupCurve8);
  walls.push(groupCurve8);
////////////////////////////////////////////////////////////////  
  var rightStraight_20 = buildStraight();

  rightStraight_20.position.set(85, 10, 0);
  rightStraight_20.point = new THREE.Vector3(85 + eps, 0, 0);
  rightStraight_20.normal = new THREE.Vector3(1, 0, 0);
  rightStraight_20.rotation.y = Math.PI / 2;
  
  var rightStraight_n1 = buildStraight();

  rightStraight_n1.position.set(135, 10, 0);
  rightStraight_n1.point = new THREE.Vector3(135 + eps, 0, 0);
  rightStraight_n1.normal = new THREE.Vector3(-1, 0, 0);
  rightStraight_n1.rotation.y = Math.PI / 2;
  
  var groupStraight5 = new THREE.Group();
  groupStraight5.add(rightStraight_n1);
  groupStraight5.add(rightStraight_20);
  groupStraight5.startLine = new THREE.Vector3(110, 0, 200);
  groupStraight5.endLine = new THREE.Vector3(110, 0, -200);
  groupStraight5.hat = new THREE.Vector3(0,0,-1)
  groupStraight5.name = 'Straight';
  scene.add(groupStraight5);
  walls1.push(groupStraight5);
/////////////////////////////////////////////////////////////////  

  var curve25 = buildCurve1();

  curve25.position.set(0, 10, -200);
  curve25.point = new THREE.Vector3(0, 0, -200);
  curve25.normal = new THREE.Vector3(0, 0, 1);
  
  var curve_n1 = buildCurve2();

  curve_n1.position.set(0, 10, -200);
  curve_n1.point = new THREE.Vector3(0, 0, -200);
  curve_n1.normal = new THREE.Vector3(0, 0, 1);
  
  var groupCurve9 = new THREE.Group();
  groupCurve9.add(curve25);
  groupCurve9.add(curve_n1);
  groupCurve9.radius = new THREE.Vector3(0, 0, -200);
  groupCurve9.startCurve = new THREE.Vector3(110, 0, -200);
  groupCurve9.endCurve = new THREE.Vector3(0, 0, -310);
  groupCurve9.angle = 90;
  groupCurve9.name = 'Curve';
  scene.add(groupCurve9);
  walls1.push(groupCurve9);
  
//////////////////////////////////////////////////////////////////  
  var curve26 = buildCurve3();

  curve26.position.set(0, 10, -370);
  curve26.point = new THREE.Vector3(0, 0, -370);
  curve26.normal = new THREE.Vector3(0, 0, 1);
  curve26.rotation.y = Math.PI/10*10;
  
  var curve_n2 = buildCurve2();

  curve_n2.position.set(0, 10, -370);
  curve_n2.point = new THREE.Vector3(0, 0, -370);
  curve_n2.normal = new THREE.Vector3(0, 0, 1);
  curve_n2.rotation.y = Math.PI/10*10;
  
  var groupCurve10 = new THREE.Group();
  groupCurve10.add(curve26);
  groupCurve10.add(curve_n2);
  groupCurve10.radius = new THREE.Vector3(0, 0, -370);
  groupCurve10.startCurve = new THREE.Vector3(0, 0, -310);
  groupCurve10.endCurve = new THREE.Vector3(-60, 0, -370);
  groupCurve10.angle = 90;
  groupCurve10.name = 'Curve';
  scene.add(groupCurve10);
  walls1.push(groupCurve10);
  
  
  var curve27 = buildCurve1();

  curve27.position.set(-170, 10, -370);
  curve27.point = new THREE.Vector3(-170, 0, -370);
  curve27.normal = new THREE.Vector3(0, 0, 1);
  
  var curve_n3 = buildCurve2();

  curve_n3.position.set(-170, 10, -370);
  curve_n3.point = new THREE.Vector3(-170, 0, -370);
  curve_n3.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve11 = new THREE.Group();
  groupCurve11.add(curve27);
  groupCurve11.add(curve_n3);
  groupCurve11.radius = new THREE.Vector3(-170, 0, -370);
  groupCurve11.startCurve = new THREE.Vector3(-60, 0, -370);
  groupCurve11.endCurve = new THREE.Vector3(-170, 0, -480);
  groupCurve11.angle = 90;
  groupCurve11.name = 'Curve';
  scene.add(groupCurve11);
  walls1.push(groupCurve11);
  
  var rightStraight_n2 = buildStraight();

  rightStraight_n2.position.set(-370, 10, -455);
  rightStraight_n2.point = new THREE.Vector3(-370, 0, -455+eps);
  rightStraight_n2.normal = new THREE.Vector3(0, 0, -1);

  
  var rightStraight_21 = buildStraight();

  rightStraight_21.position.set(-370, 10, -505);
  rightStraight_21.point = new THREE.Vector3(-370 , 0, -505+eps);
  rightStraight_21.normal = new THREE.Vector3(0, 0, 1);

  
  var groupStraight_6 = new THREE.Group();
  groupStraight_6.add(rightStraight_21);
  groupStraight_6.add(rightStraight_n2);
  groupStraight_6.startLine = new THREE.Vector3(-170, 0, -480);
  groupStraight_6.endLine = new THREE.Vector3(-570, 0, -480);
  groupStraight_6.hat = new THREE.Vector3(-1, 0, 0)
  groupStraight_6.name = 'Straight';
  scene.add(groupStraight_6);
  walls1.push(groupStraight_6);
  
//////////////////////////////////////////////////////////////////////    
  var curve28 = buildCurve1();

  curve28.position.set(-570, 10, -370);
  curve28.point = new THREE.Vector3(-570, 0, -370);
  curve28.rotation.y = Math.PI/2;
  curve28.normal = new THREE.Vector3(0, 0, -1);
  
  var curve_n4 = buildCurve2();

  curve_n4.position.set(-570, 10, -370);
  curve_n4.point = new THREE.Vector3(-570, 0, -370);
  curve_n4.rotation.y = Math.PI/2;
  curve_n4.normal = new THREE.Vector3(0, 0, -1);

  var groupCurve12 = new THREE.Group();
  groupCurve12.add(curve_n4);
  groupCurve12.add(curve28);
  groupCurve12.radius = new THREE.Vector3(-570, 0, -370);
  groupCurve12.startCurve = new THREE.Vector3(-570, 0, -480);
  groupCurve12.endCurve = new THREE.Vector3(-680, 0, -370);
  groupCurve12.angle = 90;
  groupCurve12.name = 'Curve';
  scene.add(groupCurve12);
  walls1.push(groupCurve12);
/////////////////////////////////////////////////////////////////  
  var curve29 = buildCurve3();

  curve29.position.set(-740, 10, -370);
  curve29.normal = new THREE.Vector3(0, 0, -1);
  curve29.rotation.y = -Math.PI/2;
  
  var curve_n5 = buildCurve2();

  curve_n5.position.set(-740, 10, -370);
  curve_n5.rotation.y = -Math.PI/2;
  curve_n5.normal = new THREE.Vector3(0, 0, -1);

  var groupCurve13 = new THREE.Group();
  groupCurve13.add(curve29);
  groupCurve13.add(curve_n5);
  groupCurve13.radius = new THREE.Vector3(-740, 0, -370);
  groupCurve13.startCurve = new THREE.Vector3(-680, 0, -370);
  groupCurve13.endCurve = new THREE.Vector3(-740, 0, -310);
  groupCurve13.angle = 90;
  groupCurve13.name = 'Curve';
  scene.add(groupCurve13);
  walls1.push(groupCurve13);
///////////////////////////////////////////////////////////////////
  var curve30 = buildCurve1();

  curve30.position.set(-735, 10, -200);
  curve30.normal = new THREE.Vector3(0, 0, 1);
  curve30.rotation.y = Math.PI/2;
  
  var curve_n6 = buildCurve2();

  curve_n6.position.set(-735, 10, -200);
  curve_n6.rotation.y = Math.PI/2;
  curve_n6.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve14 = new THREE.Group();
  groupCurve14.add(curve30);
  groupCurve14.add(curve_n6);
  groupCurve14.radius = new THREE.Vector3(-735, 0, -200);
  groupCurve14.startCurve = new THREE.Vector3(-735, 0, -310);
  groupCurve14.endCurve = new THREE.Vector3(-795, 0, -200);
  groupCurve14.angle = 90;
  groupCurve14.name = 'Curve';
  scene.add(groupCurve14);
  walls1.push(groupCurve14);
//////////////////////////////////////////////////////////////////////     
  var rightStraight_22 = buildStraight();

  rightStraight_22.position.set(-870, 10, 0);
  rightStraight_22.point = new THREE.Vector3(-870 + eps, 0, 0);
  rightStraight_22.normal = new THREE.Vector3(1, 0, 0);
  rightStraight_22.rotation.y = Math.PI/2;
  
  var rightStraight_n3 = buildStraight();

  rightStraight_n3.position.set(-820, 10, 0);
  rightStraight_n3.point = new THREE.Vector3(-820+eps, 0, 0);
  rightStraight_n3.rotation.y = Math.PI/2;
  rightStraight_n3.normal = new THREE.Vector3(-1, 0, 0);

  var groupStraight7 = new THREE.Group();
  groupStraight7.add(rightStraight_22);
  groupStraight7.add(rightStraight_n3);
  groupStraight7.startLine = new THREE.Vector3(-845, 0, -200);
  groupStraight7.endLine = new THREE.Vector3(-845, 0, 200);
  groupStraight7.hat = new THREE.Vector3(0, 0, 1)
  groupStraight7.name = 'Straight';
  scene.add(groupStraight7);
  walls1.push(groupStraight7);
////////////////////////////////////////////////////////////////////////
  var curve31 = buildCurve1();

  curve31.position.set(-735, 10, 200);
  curve31.rotation.y = Math.PI/10*10;
  curve31.normal = new THREE.Vector3(0, 0, 1);
  
  var curve_n7 = buildCurve2();

  curve_n7.position.set(-735, 10, 200);
  curve_n7.rotation.y = Math.PI/10 * 10 ;
  curve_n7.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve15 = new THREE.Group();
  groupCurve15.add(curve_n7);
  groupCurve15.add(curve31);
  groupCurve15.radius = new THREE.Vector3(-735, 0, 200);
  groupCurve15.startCurve = new THREE.Vector3(-845, 0, 200);
  groupCurve15.endCurve = new THREE.Vector3(-735, 0, 310);
  groupCurve15.angle = 90;
  groupCurve15.name = 'Curve';
  scene.add(groupCurve15);
  walls1.push(groupCurve15);
/////////////////////////////////////////////////////////////////////////    
  var rightStraight_23 = buildStraight1();

  rightStraight_23.position.set(-367.5, 10, 335);
  rightStraight_23.point = new THREE.Vector3(-367.5, 0, 335 + eps);
  rightStraight_23.normal = new THREE.Vector3(0, 0, -1);
  
  var rightStraight_n4 = buildStraight1();

  rightStraight_n4.position.set(-367.5, 10, 285);
  rightStraight_n4.point = new THREE.Vector3(-367.5, 0, 285+eps);
  rightStraight_n4.normal = new THREE.Vector3(0, 0, 1);

  var groupStraight8 = new THREE.Group();
  groupStraight8.add(rightStraight_23);
  groupStraight8.add(rightStraight_n4);
  groupStraight8.startLine = new THREE.Vector3(-735, 0, 310);
  groupStraight8.endLine = new THREE.Vector3(0, 0, 310);
  groupStraight8.hat = new THREE.Vector3(1, 0, 0)
  groupStraight8.name = 'Straight';
  scene.add(groupStraight8);
  walls1.push(groupStraight8);
//////////////////////////////////////////////////////////////////  
  var curve32 = buildCurve1();

  curve32.position.set(0, 10, 200);
  curve32.rotation.y = -Math.PI/2;
  curve32.normal = new THREE.Vector3(0, 0, 1);
  
  var curve_n8 = buildCurve2();

  curve_n8.position.set(0, 10, 200);
  curve_n8.rotation.y = -Math.PI/2 ;
  curve_n8.normal = new THREE.Vector3(0, 0, 1);

  var groupCurve16 = new THREE.Group();
  groupCurve16.add(curve32);
  groupCurve16.add(curve_n8);
  groupCurve16.radius = new THREE.Vector3(0, 0, 200);
  groupCurve16.startCurve = new THREE.Vector3(0, 0, 310);
  groupCurve16.endCurve = new THREE.Vector3(110, 0, 200);
  groupCurve16.angle = 90;
  groupCurve16.name = 'Curve';
  scene.add(groupCurve16);
  walls1.push(groupCurve16);
/////////////////////////////////////////////////////////////////

}

function readModel (modelName, targetSize = 20) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('model/');
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('model/');
    objLoader.load(modelName+'.obj', function(object) {
		
		carModel.add (unitize (object, 45));
		//theObject.add ( new THREE.BoxHelper (theObject) )
		//theObject.name = 'OBJ'
		scene.add (carModel);
		//theObject.position.set(0,0,0);
		//theObject.setRotationFromEuler (new THREE.Euler (3.1416/2, 0, -3.1416/2, 'ZYX'))

    }, onProgress, onError);

  });
}


////////////////////////////////////////
// wrap an Object3D around the given object
// so that it is centered at +Y axis
// 
function unitize (object, targetSize) {  
	
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	// uniform scaling according to objSize
	var objSize = Math.max (size.x, size.y, size.z);
	var scaleSet = targetSize/objSize;
				
	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
	theObject.rotation.y = 1.1;
	return theObject;
			
}

function readModel1 (modelName1, targetSize1 = 20) {

  var onProgress1 = function(xhr1) {
    if (xhr1.lengthComputable) {
      var percentComplete1 = xhr1.loaded / xhr1.total * 100;
      console.log(Math.round(percentComplete1, 2) + '% downloaded');
    }
  };

  var onError1 = function(xhr1) {};

  var mtlLoader1 = new THREE.MTLLoader();
  mtlLoader1.setPath('model/');
  mtlLoader1.load(modelName1+'.mtl', function(materials1) {

    materials1.preload();

    var objLoader1 = new THREE.OBJLoader();
    objLoader1.setMaterials(materials1);
    objLoader1.setPath('model/');
    objLoader1.load(modelName1+'.obj', function(object1) {
		
		carnModel.add (unitize1 (object1, 40));
		//theObject.add ( new THREE.BoxHelper (theObject) )
		//theObject.name = 'OBJ'
		scene.add (carnModel);
		//theObject.position.set(0,0,0);
		//theObject.setRotationFromEuler (new THREE.Euler (3.1416/2, 0, -3.1416/2, 'ZYX'))

    }, onProgress1, onError1);

  });
}

function unitize1 (object1, targetSize1) {  
	
	// find bounding box of 'object'
	var boxn3 = new THREE.Box3();
	boxn3.setFromObject (object1);
	var size1 = new THREE.Vector3();
	size1.subVectors (boxn3.max, boxn3.min);
	var center1 = new THREE.Vector3();
	center1.addVectors(boxn3.max, boxn3.min).multiplyScalar (0.5);
	
	console.log ('center: ' + center1.x + ', '+center1.y + ', '+center1.z );
	console.log ('size: ' + size1.x + ', ' +  size1.y + ', '+size1.z );
	
	// uniform scaling according to objSize
	var objSize1 = Math.max (size1.x, size1.y, size1.z);
	var scaleSet1 = targetSize1/objSize1;
				
	var theObject1 =  new THREE.Object3D();
	theObject1.add (object1);
	object1.scale.set (scaleSet1, scaleSet1, scaleSet1);
	object1.position.set (-center1.x*scaleSet1, -center1.y*scaleSet1, -center1.z*scaleSet1);
	theObject1.rotation.y = -Math.PI/2;
	return theObject1;
			
}


////////////////////////////////////////
// wrap an Object3D around the given object
// so that it is centered at +Y axis
// 


function animate() {
var delta = clock.getDelta();
	floor.material.uniforms[ "time" ].value += delta/15;

  car.mesh.children[0].rotation.y += 0.02;
  car.mesh.children[1].rotation.y -= 0.02;
  car.mesh.children[2].rotation.y += 0.02;
  car.mesh.children[3].rotation.y -= 0.02;
  
  car1.mesh.children[0].rotation.y += 0.02;
  car1.mesh.children[1].rotation.y -= 0.02;
  car1.mesh.children[2].rotation.y += 0.02;
  car1.mesh.children[3].rotation.y -= 0.02;
  

  if (walls[a].name == 'Straight') //判斷直道
  {
  
    if (rightTop.clone().sub(walls[a].children[0].point).dot(walls[a].children[0].normal) < eps + 1 || leftTop.clone().sub(walls[a].children[1].point).dot(walls[a].children[1].normal) < eps + 1 || rightButtom.clone().sub(walls[a].children[0].point).dot(walls[a].children[0].normal) < eps + 1 || leftButtom.clone().sub(walls[a].children[1].point).dot(walls[a].children[1].normal) < eps + 1) {
	  //car.collisionSound.play();
      car.speed = 0;
    }


    let dis3 = new THREE.Vector3();
    dis3 = carFrontPos.clone().sub(walls[a].startLine).dot(walls[a].hat);
   if (walls[a].startLine.distanceTo(walls[a].endLine) <= dis3) 
      a++;
	  
	  
}
 else if (walls[a].name == 'Curve') //判斷彎道
  {

	if(leftTop.clone().distanceTo(walls[a].radius) < rightTop.clone().distanceTo(walls[a].radius) + eps ){
    if (leftTop.clone().distanceTo(walls[a].radius) > eps + 84 || leftTop.clone().distanceTo(walls[a].radius) < eps + 36 || rightTop.clone().distanceTo(walls[a].radius) > eps + 84 || rightTop.clone().distanceTo(walls[a].radius) < eps + 36 || leftButtom.clone().distanceTo(walls[a].radius) > eps + 84 || leftButtom.clone().distanceTo(walls[a].radius) < eps + 36 || rightButtom.clone().distanceTo(walls[a].radius) > eps + 84 || rightButtom.clone().distanceTo(walls[a].radius) < eps + 36) {
      //car.collisionSound.play();
      car.speed = 0;
    }
	}
	else{
	if (leftTop.clone().distanceTo(walls[a].radius) > eps + 134 || leftTop.clone().distanceTo(walls[a].radius) < eps + 86 || rightTop.clone().distanceTo(walls[a].radius) > eps + 134 || rightTop.clone().distanceTo(walls[a].radius) < eps + 86 || leftButtom.clone().distanceTo(walls[a].radius) > eps + 134 || leftButtom.clone().distanceTo(walls[a].radius) < eps + 86 || rightButtom.clone().distanceTo(walls[a].radius) > eps + 134 || rightButtom.clone().distanceTo(walls[a].radius) < eps + 86) {
      //car.collisionSound.play();
      car.speed = 0;
    }
	}

	
    let radiusX = new THREE.Vector3();
    let radiusZ = new THREE.Vector3();
    let startX = new THREE.Vector3();
    let startZ = new THREE.Vector3();
    let endX = new THREE.Vector3();
    let endZ = new THREE.Vector3();

    radiusX = walls[a].radius.dot(new THREE.Vector3(1, 0, 0));
    radiusZ = walls[a].radius.dot(new THREE.Vector3(0, 0, 1));
    startX = walls[a].startCurve.dot(new THREE.Vector3(1, 0, 0));
    startZ = walls[a].startCurve.dot(new THREE.Vector3(0, 0, 1));
    endX = walls[a].endCurve.dot(new THREE.Vector3(1, 0, 0));
    endZ = walls[a].endCurve.dot(new THREE.Vector3(0, 0, 1));

    let c1 = THREE.Math.radToDeg(Math.atan2(startZ - radiusZ, startX - radiusX));
    let c2 = THREE.Math.radToDeg(Math.atan2(endZ - radiusZ, endX - radiusX));
    let c3 = THREE.Math.radToDeg(Math.atan2(carFrontPos.z - radiusZ, carFrontPos.x - radiusX));
    let angle, angle1;
    //夾角獲取
    angle = Math.floor(c2 - c1);
    angle1 = Math.floor(c3 - c1);
    if (angle1 < 0) {
      angle1 += 360;
    }

    if (angle1 > 90) {
      angle1 -= 270;
    }
    if (angle1 > walls[a].angle || angle1 < 0) 
      a++;


  }
  if (a == 12) {
    a = 0;
    car.speed = 0;
  }
/////////////////////////////////////////////////////////////////////////////////////////////////////  
  console.log(b);
  if (walls1[b].name == 'Straight') //判斷直道
  {
  
    if (rightTop1.clone().sub(walls1[b].children[0].point).dot(walls1[b].children[0].normal) < eps + 1 || leftTop1.clone().sub(walls1[b].children[1].point).dot(walls1[b].children[1].normal) < eps + 1 || rightButtom1.clone().sub(walls1[b].children[0].point).dot(walls1[b].children[0].normal) < eps + 1 || leftButtom1.clone().sub(walls1[b].children[1].point).dot(walls1[b].children[1].normal) < eps + 1) {
	  //car.collisionSound.play();
      car1.speed = 0;
    }


    let dis3 = new THREE.Vector3();

    dis3 = carFrontPos1.clone().sub(walls1[b].startLine).dot(walls1[b].hat);
		console.log(dis3,walls1[b].startLine.distanceTo(walls1[b].endLine) )
   if (walls1[b].startLine.distanceTo(walls1[b].endLine) <= dis3) 
      b++;
	  
	  
}
 else if (walls1[b].name == 'Curve') //判斷彎道
  {
	if(leftTop1.clone().distanceTo(walls1[b].radius) > rightTop1.clone().distanceTo(walls1[b].radius) + eps ){
    if (leftTop1.clone().distanceTo(walls1[b].radius) > eps + 84 || leftTop1.clone().distanceTo(walls1[b].radius) < eps + 36 || rightTop1.clone().distanceTo(walls1[b].radius) > eps + 84 || rightTop1.clone().distanceTo(walls1[b].radius) < eps + 36 || leftButtom1.clone().distanceTo(walls1[b].radius) > eps + 84 || leftButtom1.clone().distanceTo(walls1[b].radius) < eps + 36 || rightButtom1.clone().distanceTo(walls1[b].radius) > eps + 84 || rightButtom1.clone().distanceTo(walls1[b].radius) < eps + 36) {
      //car.collisionSound.play();
      car1.speed = 0;
    }
	}
	else{
	if (leftTop1.clone().distanceTo(walls1[b].radius) > eps + 134 || leftTop1.clone().distanceTo(walls1[b].radius) < eps + 86 || rightTop1.clone().distanceTo(walls1[b].radius) > eps + 134 || rightTop1.clone().distanceTo(walls1[b].radius) < eps + 86 || leftButtom1.clone().distanceTo(walls1[b].radius) > eps + 134 || leftButtom1.clone().distanceTo(walls1[b].radius) < eps + 86 || rightButtom1.clone().distanceTo(walls1[b].radius) > eps + 134 || rightButtom1.clone().distanceTo(walls1[b].radius) < eps + 86) {
      //car.collisionSound.play();
      car1.speed = 0;
    }
	}

	
    let radiusX = new THREE.Vector3();
    let radiusZ = new THREE.Vector3();
    let startX = new THREE.Vector3();
    let startZ = new THREE.Vector3();
    let endX = new THREE.Vector3();
    let endZ = new THREE.Vector3();

    radiusX = walls1[b].radius.dot(new THREE.Vector3(1, 0, 0));
    radiusZ = walls1[b].radius.dot(new THREE.Vector3(0, 0, 1));
    startX = walls1[b].startCurve.dot(new THREE.Vector3(1, 0, 0));
    startZ = walls1[b].startCurve.dot(new THREE.Vector3(0, 0, 1));
    endX = walls1[b].endCurve.dot(new THREE.Vector3(1, 0, 0));
    endZ = walls1[b].endCurve.dot(new THREE.Vector3(0, 0, 1));

    let c1 = THREE.Math.radToDeg(Math.atan2(startZ - radiusZ, startX - radiusX));
    let c2 = THREE.Math.radToDeg(Math.atan2(endZ - radiusZ, endX - radiusX));
    let c3 = THREE.Math.radToDeg(Math.atan2(carFrontPos1.z - radiusZ, carFrontPos1.x - radiusX));
    let angle, angle1;
    //夾角獲取
    angle = Math.floor(c2 - c1);
    angle1 = Math.floor(c3 - c1);
    if (angle1 < 0) {
      angle1 += 360;
    }

    if (angle1 > 90) {
      angle1 -= 270;
    }
    if (angle1 > walls1[b].angle || angle1 < 0) 
      b++;


  }
  if (b == 12) {
    b = 0;
    car1.speed = 0;
  }

carModel.position.copy(car.pos);
carnModel.position.copy(car1.pos);

  car.update(dt);
  car1.update(dm);
  
    camera.lookAt(car.pos);
  
  angle1 += 0.01;
  SpotLight.position.set(400 * Math.cos(angle1), 700, 800 * Math.sin(angle1));
  lightSphere.position.copy(SpotLight.position);
  
  if(keyboard.down("P") || keyboard.pressed("P")){
	camera.position.set(200,300,200);
  }

  var cameraOffset = car.mesh.localToWorld(new THREE.Vector3(0, 30, 50));
  camera3rd.position.copy(cameraOffset);
  camera3rd.lookAt(car.pos);
  
  if(keyboard.down("Q") || keyboard.pressed("Q")){
	camera3rd.position.copy(car.mesh.localToWorld(new THREE.Vector3(0, 30, -100)));
	camera3rd.lookAt(car.pos);
  }

  var cameraOffset1 = car1.mesh.localToWorld(new THREE.Vector3(0, 30, 50));
  camera3rd1.position.copy(cameraOffset1);
  camera3rd1.lookAt(car1.pos);


  updateSize();
  requestAnimationFrame(animate);
  renderer.setViewport(1, 1, windowHalfX, windowHalfY);
  renderer.clear();

  camera.aspect = windowHalfX / windowHalfY;
  camera.updateProjectionMatrix();
  renderer.setViewport(0, 0, windowHalfX, 0.5*windowHalfY);
  renderer.render(scene, camera);

  camera3rd.aspect = (windowHalfX / 2) / windowHalfY;
  camera3rd.updateProjectionMatrix();
  renderer.setViewport(0, windowHalfY / 2, 0.5 * windowHalfX, 0.5 * windowHalfY);
  renderer.render(scene, camera3rd);

  camera3rd1.aspect = (windowHalfX / 2) / windowHalfY;
  camera3rd1.updateProjectionMatrix();
  renderer.setViewport(windowHalfX / 2, windowHalfY / 2, 0.5 * windowHalfX, 0.5 * windowHalfY);
  renderer.render(scene, camera3rd1);
  
}
</script>
</body> 
</html>